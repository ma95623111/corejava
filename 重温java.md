# 重温java ～ day2

## 1. 引用类型

​		在Java中除了基本数据类型以外的都是引用类型。

**什么是子类？**

​		通常一个类A继承(extends)另一个类B，我们称A为子类，B为父类

**什么是实现类**

​		通常一个类A实现(implements)另一个接口B，我们称A为实现类

## 2. 类型转换

### 2.1自动转换

​		自动转换（又称隐式转换）通常指由下向上的转换过程，转换规则如下(由左至右依次转换，为隐式转换)

> 整数：byte -> short -> int -> long
>
> 浮点数：float -> double
>
> 类型：子类或实现类 -> 父类或接口

### 2.2 强制类型转换

​		强制类型转换其实就是自动转换的反例，在类型转换时，要显示的声明转换类型。

## 3. == 与 equals

​		==操作符专门用来比较变量的值是否相同。

- 基本数据类型：比较的是他们的值是否相同。
- 引用数据类型：比较的是他们的内存地址是否同一地址。

​		equals方法常用来比较对象的内容是否相同。

## 4. 字符串

​		字符串是Java中最常用的类型，它是由java默认提供的，我们需要记得每次进行字符串拼接和字符串方法调用时的时候都会创建一个新的字符串。

> 注意：上述中的拼接会创建新的字符串是指在编译期无法确定字符串的最终结果时，才会创建新的字符串

​		字符串的方法可以查看响应的Api，官方地址https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html

# 重温java ～ day3

## 1. BigDecimal 

> 参考代码：BigDecimalLearn

​		BigDecimal是大数值浮点数，该类中提供了很多的用于计算的方法，例如简单的加减乘除等，BigDecimal类多用于进行金额的计算，其原因是BigDecimal在计算后能保证精度问题，不像double和float那样。

​		对于技术我们保持着怀疑的态度去学习，BigDecimail不会精度丢失么？**经过测试BigDecimal也会精度丢失**。

​		造成精度丢失的原因是，计算机无法精确的表示浮点数，所以当BigDecimal对象接受浮点数时，就已经是丢失精度的。

> 使用BigDecimal注意事项
>
> 1. 在给BigDecimal赋值浮点数时，要是用字符串进行复制
> 2. 比较BigDecimal时，建议使用BigDecimal自带的compareTo方法
> 3. BigDecimal不可以表示无限循环小数，在特定的场景下要适当的约束位数

## 2. 数组

​		数组书里已经讲的很全了，就不过多展示，对于数组需要多看看Arrays类，它提供了很多对于数组操作的方法，例如排序、复制等。

​		数组其实没有什么好注意的地点，唯一注意的就是获取数组中元素时，不要越界。

## 3. 抽象类与接口

​		抽象类与接口书里的定义已经很清楚了，我们说下它俩的区别

> jdk1.8之前区别
>
> 1. 抽象类中可以有抽象方法和具体方法，接口中方法全部是抽象方法。（抽象方法的都是public权限的）
> 2. 抽象类可以实例化，接口不能实例化. New
> 3. 抽象类仅能被继承，接口只能被实现
>
> Jdk1.8及以后版本区别
>
> ​	jdk1.8以后版本的区别就仅剩下上述的3了，下面讲讲述1.8以后的接口改动

**jdk1.8版本及之后版本接口改动**

1. 接口可以有具体方法，只需要使用static或default定义方法即可
2. 接口可以实例化，但要实现接口中的抽象方法

## 4. 基本类型包装类与自动拆、装箱

​		Java提供的8个基本类型都有与之对应的包装类型，这个包装类型可以看作是一个引用类型。

​		为什么java要提供基础类型的包装类？

​		这是因为在某些场景下我们要只能使用引用类型，例如：定义一个List时，限定List中仅能存储int元素类型时就只能使用对应的Integer包装类型

​		**自动拆、装箱**

​		装箱就是基本类型转换包装类型；拆箱就是包装类型转换基本类型；自动的含义其实就是这个转换的过程java自己隐形的支持，不需要开发人员去手动的编写类型转换

> 代码见AutoTransType

## 5. 关键字及方法

​		**instanceof**

​		判断一个对象是否是一个类的子类 或者 一个类是否是一个接口的实现

​		**Class.isAssignableFrom()**

​		判断一个类是否是另一个类的子类或者实现类

​		**break**	

​		退出循环

​		**continue**

​		跳出本次循环





# 扩展

## 1. 浮点数转二进制

整数部分：

1. 整数部分不断除以2，保存商和余数。
2. 判断商是否等于0，如果等于0到第3步，否则回到第1步。
3. 将每一步得到的余数倒序保存，得到整数部分的二进制表示。

小数部分：

1. 小数部分不断乘以2，保存结果的整数和小数。
2. 判断结果的整数是否等于1，如果等于1到第3步，否则回到第1步。
3. 将每一步结果的所有整数顺序保存，就得到小数的二进制表示

例如：浮点数 `4.8125`
 整数部分：

```undefined
4/2     = 2     0
2/2     = 1     0
1/2     = 0     1
所以整数部分 4 的二进制为 100
```

小数部分：

```undefined
0.8125*2    = 1.625     1
0.625*2     = 1.25      1
0.25*2      = 0.5       0
0.5*2       = 1.0       1
所以小数部分 0.8125 的二进制位 1101
```

将整数与小数部分连接起来就是 `100.1101`，即![4.8125](https://math.jianshu.com/math?formula=4.8125)=![100.1101_2](https://math.jianshu.com/math?formula=100.1101_2)

再如：浮点数 `0.05`
 因为只有小数所以只处理小数部分：

```undefined
0.05*2      = 0.1 0
0.1*2       = 0.2 0
0.2*2       = 0.4 0
0.4*2       = 0.8 0

0.8*2       = 1.6 1
0.6*2       = 1.2 1
0.2*2       = 0.4 0
0.4*2       = 0.8 0

0.8*2       = 1.6 1
0.6*2       = 1.2 1
0.2*2       = 0.4 0
0.4*2       = 0.8 0

0.8*2       = 1.6 1 
......      无限循环


所以0.05的二进制 = 0.0000 1100 1100 1100 1100 1100 1101 .... 
```

可以看到二进制小数是无法准确表示浮点数的，所以就有了精度一说.
 单精度浮点数用32位二进制表示如下：

```undefined
符号位1位  阶码8位  小数位23位
```

![png1](/Users/mzc/Desktop/mzc learn/lecture/corejava/corejava/png1.webp)

双精度浮点数用64位二进制表示如下：

```undefined
符号位1位  阶码11位  小数位52位
```

![2png](/Users/mzc/Desktop/mzc learn/lecture/corejava/corejava/2png.webp)

双精度.png

由上可知，
 单精度浮点数精度为 `pow(2,23) = 8388608 = 0.8388608 x pow(10,7)`
 所以单精度浮点数对应的10进制精度为 `7` 位多
 双精度浮点数精度为 `pow(2,52)-1 = 4503599627370496 = 0.4503599627370496 x pow(10,16)`
 所以双精度浮点数对应的10进制精度为 `16` 位多
